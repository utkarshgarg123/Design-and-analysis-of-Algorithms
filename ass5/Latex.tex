\documentclass[conference]{IEEEtran}
\documentclass{article}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{textcomp}
\usepackage{epsfig}
\usepackage{algpseudocode}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{graphicx}
\pgfplotsset{width=10cm,compat=1.9}
 \usepgfplotslibrary{external}
 \graphicspath{ {./images/} }



\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage[ruled,vlined]{algorithm2e}

\tikzexternalize 
\begin{document}

\title{Find the maximum length snake sequence  \\
\text{\Large{DAA ASSIGNMENT-4 , GROUP 8}}
}
\author{\IEEEauthorblockN{Swaraj Bhosle}
\IEEEauthorblockA{ \text{IIT2019024}}
\and
\IEEEauthorblockN{Ritesh Raj}
\IEEEauthorblockA{ \text{IIT2019025}}
\and
\IEEEauthorblockN{Utkarsh Garg}
\IEEEauthorblockA{ \text{IIT2019026}}
}

\maketitle
{\textbf{\textit{Abstract—In this paper, we are devising an algorithm to find
the maximum length snake sequence in a given matrix. This
paper also contains the algorithm’s time and space complexity
analysis. \\
Index Terms—matrix, array, dynamic programming, time
complexity, space complexity. \\ 
}}}
\maketitle

\section{INTRODUCTION}\\
A matrix of integers of size n*m is given, our algorithm
should find the longest snake sequence from the matrix. If
there exist many, it should print any one. There are some
constraints for making snake sequence, 

• snake sequence is made up of adjacent numbers in the grid.
 
• for each number, adjacent number on the right or below
should be +1 or -1 of its value.
     \\
Matrix: Two dimensional arrays are called matrices.
Dynamic Programming: It is an algorithmic technique for
solving an optimization problem by breaking it down into
simpler sub-problems and utilizing the fact that the optimal
solution to the overall problem depends upon the optimal
solution to its sub-problems.\\
% \\ This report further contains - 
% \renewcommand{\labelenumi}{\Roman{enumi}}
% \begin{enumerate}
% \setcounter{enumi}{1}
%     \item Algorithm Design.
%     \item Algorithm And  Analysis.
%     \item Time Calculation
%     \item Time Complexity
%     \item References\\
% \end{enumerate}

\section{ALGORITHM DESIGN}\\

We have 2 objectives for given problem:

• to find the length of the longest path which satisfies the
given constraints.

• to print the longest path.
Nomenclature
\begin{center}
  $len[x][y] : maximum length of sequence$  
\end{center}
\begin{center}
  $ending at cell (x, y)$  
\end{center}

Now it is given that we can only move in right or down
direction when we are at a given cell in matrix. So for each
cell, we can have the following recurrence relation
\begin{center}
 $len[x][y] = max(len[x − 1][y], len[x][y − 1]) + 1$
\end{center}

\\
Assuming that the cells at $(x-1, y)$ and $(x, y-1)$ are valid with
respect to given cell. Take, $len[0][0] = 0$, because starting cell
will end on itself.\\
  So, in order to find the length ending at cell $(x, y)$ we need
cells $(x-1, y)$ and$(x, y-1)$. We are going to keep track of all
of this to make sure that finding length at any cell costs $O(1)$
time.\\
This formula has given us a way of essentially calculating
the value of longest path ending at any cell $(x, y)$. Only thing
left is that we check which cell has the longest path and print
that answer.\\
Now the remaining task is to print path. How to do it?
Using an array which essentially keeps track of all the last
value of the cell that have came inside the array. We can
backtrack whole answer and store all these indexes in a array.
Once we reach the starting point of the array we can print the
answer in reverse order.\\
Algorithm 1 shows the complete approach for calculating
distance. Algorithm 2 shows the complete approach for
printing path.

\section{ALGORITHM AND ANALYSIS}\\
So, for each cell we require $O(1)$ time for comparison, and
we have to repeat this for each and every cell and then find
the longest possible length. Also, to keep track of last indexes
and distance we will need an array.

\textbf{A. Time Complexity}\\
We have found out time complexity to be: $O(n*m)$, as total
number of comparisons will be in the order of $O(n*m)$.

\textbf{B. Space Complexity}\\
Since, we will need 2 two-dimensional arrays of size n*m
i.e. $O(n*m)$, and other variables require constant space. So,
overall space complexity is $O(n*m)$.
\section{EXPERIMENTAL ANALYSIS}\\
For conducting the experiment we have made a $testgenerator.cpp$ file. First we are going to generate 2 random numbers
n and m; then we will generate n*m random values.\\
The range of n ans m is as below:-
\begin{center}
    $1 \le n\le 1000$
\end{center}
\begin{center}
    $1\le m\le 1000$
\end{center}
    


To make sure that random values generated for each case
are not same we are have used to seed function to change
the initial seeding of random values. The initial seeding will
depend on the time of execution of program. This test case
generator file will create a $input.txt$, which is further used in
our main program.


% \begin{algorithm}[H] 
%     \caption{ DP approach for calculating length of
% sequence }
%     \KwIn{Matrix of integers }
%     \KwOut {Length of longest snake sequence}
%     \DontPrintSemicolon
%     \SetKwFunction{FMain}{longestSequences}
%     \SetKwProg{Fn}{Function}{:}{}
%     \Fn{\FMain{$int$ $n$, $int$ $m$}}{
%     \\ \textbf{int}  dp[n][m] ←− 0;\\
%      \\ \textbf{int} p[n][m] ←− −1;\\   
%      \\ \textbf{int} ans ←− −0;\\       
 
       

   
%   }
%     \SetKwFunction{FMain}{Main}
%     \SetKwProg{Fn}{Function}{:}{}
%     \Fn{\FMain{}}{
         
%          \\\text{Get $M$;}
%           \\\text{Get $N$;}
%           \\ \textbf{int} DP[M][N]={-1}
%           \\\textbf{Print}
%           \text{(TotalSequences($M$, $N$))}
        
         
% }



\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.60]{Pic3.jpeg}
\end{figure}
\\

\\

\\

\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.60]{Pic4.jpeg}
\end{figure}
 
% \end{algorithm}\\
\\


\section{TIME CALCULATION }\\
\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.50]{Pic1.jpeg}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.50]{Pic2.jpeg}
\end{figure}

% \section{TIME CALCULATION}\\
\begin{center}
 \begin{tabular}{||c c c||} 
 \hline
  BEST & AVERAGE & WORST CASE  \\  
 \hline\hline
 \begin{math} \mathcal{O}(M*N)\end{math} & \begin{math} \mathcal{O}(M*N)\end{math} & \begin{math} \mathcal{O}(M*N)\end{math} \\ 
 \hline
\end{tabular}
\end{center}

\section{CONCLUSION}
In this document we discussed about the question which
required concepts from dynamic programming to solve the
problem. First if all we came up with a recursive formulae
to get the desired answer. Then using appropriate tabulation,
we have iteratively solved the problem to find the maximum
length of snake sequence from input matrix.\\
Given problem could have been solved without using dynamic programming but, it would require more space and
time complexity. So, we finally came up with an efficient
approach that uses dynamic programming and finds our answer
in $O(n*m)$ time and space complexity.\\
Fig 2 shows the comparison between the time complexities
of naive and dynamic programming based approach to solve
above problem.


\section{REFERENCES}
\begin{enumerate}
    \item \url{https://www.geeksforgeeks.org/find-maximum-length-snake-sequence/}
    \item \url{https://en.wikipedia.org/wiki/Dynamics}
     \item \url{https://www.javatpoint.com/dynamic-programming-introduction}
\end{enumerate}
\end{document}
